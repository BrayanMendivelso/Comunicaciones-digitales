from machine import Pin, SPI, I2C, ADC
from nrf24l01 import NRF24L01
import utime
# --- Configuraci√≥n NRF24L01 ---
spi = SPI(0, sck=Pin(6), mosi=Pin(7), miso=Pin(4))
csn = Pin(15, Pin.OUT)
ce = Pin(14, Pin.OUT)
nrf = NRF24L01(spi, csn, ce, channel=76, payload_size=32)
nrf.open_tx_pipe(b'\xe1\xf0\xf0\xf0\xf0')  # Direcci√≥n hacia RX
nrf.open_rx_pipe(1, b'\xd2\xf0\xf0\xf0\xf0')
# --- Configuraci√≥n I2C (MPU6050) ---
i2c = I2C(1, scl=Pin(11), sda=Pin(10))
MPU_ADDR = 0x69  # Direcci√≥n del sensor MPU6050
# Despertar el sensor
i2c.writeto_mem(MPU_ADDR, 0x6B, b'\x00')
def read_word(reg):
    """Lee un valor de 16 bits del registro indicado"""
    high = i2c.readfrom_mem(MPU_ADDR, reg, 1)[0]
    low = i2c.readfrom_mem(MPU_ADDR, reg + 1, 1)[0]
    value = (high << 8) | low
    if value >= 0x8000:
        value = -((65535 - value) + 1)
    return value

def read_accel():
    """Lee los valores del aceler√≥metro (Ax, Ay, Az)"""
    ax = read_word(0x3B) / 16384.0
    ay = read_word(0x3D) / 16384.0
    az = read_word(0x3F) / 16384.0
    return ax, ay, az
# --- Joystick ---
xAxis = ADC(Pin(27))  # Eje X
yAxis = ADC(Pin(26))  # Eje Y

print("üöÄ Transmisor listo. Enviando datos...")
# --- Bucle principal ---
while True:
    try:
        # Leer aceler√≥metro
        ax, ay, az = read_accel()
        # Leer joystick
        x_val = xAxis.read_u16()
        y_val = yAxis.read_u16()
        # Convertir joystick X a √°ngulo (0‚Äì180)
        angulo = int((x_val / 65535) * 180)
        angulo = max(0, min(180, angulo))  # Limitar entre 0¬∞ y 180¬∞
        # Enviar datos
        mensaje = f"ACC,{ax:.2f},{ay:.2f},{az:.2f},SERVO,{angulo}"
        nrf.send(mensaje.encode())
        print("üì§ Enviado:", mensaje)
    except OSError:
        print("‚ö†Ô∏è Error al enviar datos")
    utime.sleep(0.3)


from machine import Pin, SPI, I2C, PWM
from nrf24l01 import NRF24L01
from ssd1306 import SSD1306_I2C
import utime

# --- NRF24L01 ---
spi = SPI(0, sck=Pin(6), mosi=Pin(7), miso=Pin(4))
csn = Pin(15, Pin.OUT)
ce = Pin(14, Pin.OUT)
nrf = NRF24L01(spi, csn, ce, channel=76, payload_size=32)
nrf.open_tx_pipe(b'\xd2\xf0\xf0\xf0\xf0')  # Direcci√≥n inversa
nrf.open_rx_pipe(1, b'\xe1\xf0\xf0\xf0\xf0')
nrf.start_listening()

# --- OLED ---
i2c = I2C(1, scl=Pin(11), sda=Pin(10))
oled = SSD1306_I2C(128, 64, i2c)
oled.fill(0)
oled.text("RX listo...", 10, 0)
oled.text("Esperando datos...", 0, 20)
oled.show()

# --- Servo ---
servo = PWM(Pin(0))
servo.freq(50)  # 50 Hz (t√≠pico de servo)
def set_angle(angle):
    # Mapear √°ngulo (0-180) ‚Üí ciclo √∫til (duty_u16)
    duty = int((angle / 180) * 6553 + 1638)  # 1638 ‚âà 0.5ms, 8191 ‚âà 2.5ms
    servo.duty_u16(duty)

print("üü¢ Receptor listo. Esperando datos del TX...")

# --- Bucle principal ---
while True:
    if nrf.any():
        msg = nrf.recv()
        texto = msg.decode('utf-8', 'ignore').replace('\x00', '').strip()
        print("üì© Recibido:", texto)
        
        if texto.startswith("ACC,"):
            try:
                partes = texto.split(",")
                ax = float(partes[1])
                ay = float(partes[2])
                az = float(partes[3])
                angulo = int(partes[5]) if len(partes) > 5 else 90

                # Actualizar servo
                set_angle(angulo)

                # Mostrar en OLED
                oled.fill(0)
                oled.text("üì° RX - Datos:", 0, 0)
                oled.text(f"Ax: {ax:.2f}", 0, 15)
                oled.text(f"Ay: {ay:.2f}", 0, 30)
                oled.text(f"Az: {az:.2f}", 0, 45)
                oled.text(f"Servo: {angulo}¬∞", 0, 58)
                oled.show()
            
            except Exception as e:
                print("‚ö†Ô∏è Error procesando:", e)
                oled.fill(0)
                oled.text("‚ö†Ô∏è Error al leer", 0, 25)
                oled.show()

    utime.sleep(0.1)


